<!DOCTYPE html>
<html lang="en" class="grid">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>less game, more website - scene 2</title>

    <style>
      html {
        font-family: 'Times New Roman', Times, serif;
        font-size: 18px;
      }

      body {
        border: 5px inset lightgray;
        box-sizing: border-box;
        margin: 0;
        /* hardcoded page size */
        height: 1000px;
        width: 2000px;
      }

      .grid {
        background-size: 50px 50px;
        background-image:
          linear-gradient(to right, lightgray 1px, transparent 1px),
          linear-gradient(to bottom, lightgray 1px, transparent 1px);
      }

      main {
        margin: 2rem 0;
      }

      button, a {
        margin: 2px;
      }

      a, a:visited {
        font-size: 1.25rem;
        color: blue;
      }

      .toggle {
        margin-left: 2rem;
        font-size: 1rem;
        position: fixed;
        top: 10px;
        right: 10px;
      }

      /* important for sizing and positioning */
      figure, section {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      #you {
        z-index: 99;
        font-weight: bold;
        text-decoration: underline;
        color: black;
        background-color: white;
        border-radius: 25px;
        height: 45px;
        width: 45px;
      }

      #next {
        background-color: white;
        border-radius: 25px;
        margin: 0;
        padding: 0;
      }

      #direction {
        background-color: white;
        color: black;
        display: inline-block;
        font-size: 1.125rem;
        font-style: italic;
        margin: 1px;
        max-width: 700px;
        padding: 10px;
        position: fixed;
        top: 50px;
        left: max(51px, calc(50% - 350px));
        z-index: 2;
      }

      .direction-button {
        margin-top: 15px;
        font-size: 1rem;
        display: block;
      }

      .direction-choice {
        display: block;
        margin-top: 15px;
        font-style: normal;
      }

      .direction-choice > input[type="radio"] {
        height: 15px;
        width: 15px;
        margin: 0 10px 0 0;
      }

      .cell {
        height: 50px;
        width: 50px;
      }

      .tree {
        background-color: green;
        color: white;
      }

      .intro {
        background-color: purple;
        color: white;
      }

      .intro > input {
        width: 15px;
        height: 15px;
      }

      .pen {
        background-color: black;
        color: white;
      }

      #ocean {
        background-color: blue;
        color: white;
        height: calc(50px * 12);
        width: calc(2000px);
      }

      #island {
        border: 10px dashed blue;
        border-left: none;
        border-right: none;
        background-color: sienna;
        color: white;
        height: 500px;
        width: 2000px;
      }

      .left { 
        padding: 10px;
      }

      .center {
        /* To center any text */
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
        flex-wrap: wrap;
        user-select: none;
      }

      .hidden {
        display: none;
      }
    </style>
    <script>
      const GRID_SIZE_PX = 50
      const CAN_SCROLL = false
      const UP = 'up'
      const DOWN = 'down'
      const LEFT = 'left'
      const RIGHT = 'right'

      const initialPositions = {
        "#you": [{ x: 1, y: 9 }],
        ".tree": [
          { x: 1, y: 5 },
          { x: 3, y: 12 },
          { x: 4, y: 10 },
          { x: 4, y: 11 },
          { x: 5, y: 10 }, // active
          { x: 6, y: 10 },
          { x: 6, y: 7 },
          { x: 10, y:12 }, // active
        ],
        ".intro": [
          { x: 17, y: 6 },
          { x: 17, y: 10 },
          { x: 17, y: 14 },
          { x: 21, y: 6 },
          { x: 21, y: 10 },
          { x: 21, y: 14 },
        ],
        ".pen": [{x: 31, y: 7}],
        "#island": [{ x: 0, y: 5, center: false }],
        "#ocean": [{ x: 0, y: 4, center: false }],
        "#signature": [{x: 30, y: 10, center: false }],
        "#next": [{ x: 38, y: 9 }],
      }

      const state = {
        boundaries: [
          {startX: 0, startY: 0, endX: 2000/50 - 1, endY: 1000/50 - 1},
        ],
        obstacles: [],
        activeArea: null,
        activeAreas: [
          {startX: 5, startY: 9, endX: 5, endY: 11, activation: direction1 },
          {startX: 9, startY: 11, endX: 11, endY: 13, activation: direction2 },
          {startX: 16, startY: 5, endX: 18, endY: 7, activation: () => activateCheckbox(1) },
          {startX: 16, startY: 9, endX: 18, endY: 11, activation: () => activateCheckbox(2) },
          {startX: 16, startY: 13, endX: 18, endY: 15, activation: () => activateCheckbox(3) },
          {startX: 20, startY: 5, endX: 22, endY: 7, activation: () => activateCheckbox(4) },
          {startX: 20, startY: 9, endX: 22, endY: 11, activation: () => activateCheckbox(5) },
          {startX: 20, startY: 13, endX: 22, endY: 15, activation: () => activateCheckbox(6) },
          {startX: 30, startY: 6, endX: 32, endY: 8, activation: chooseSignature },

          // {startX: 18, startY: 11, endX: 20, endY: 13,
          //   activation: () => {
          //     updateDirection("TBD")
          //     const next = document.getElementById("next")
          //     if (next) {
          //       next.classList.remove("hidden")
          //       state.activeAreas.push({startX: 37, startY: 9, endX: 39, endY: 11, activation: () => window.location.assign("./websitevibe-scene3.html")})
          //     }
          //   }
          // },
          
        ]
      }

      function direction1() {
        updateDirection("On your island, the first thing to do is find three travellers you trust to act as introduction points to you and the outside world.")
      }

      function direction2() {
        updateDirection("These three connections are the only contacts you'll trust. Got it? <button class='direction-button' onclick='resetDirection()'>okay</button>")
      }

      function chooseSignature() {
        updateDirection(`Now, you pick a unique, hard-to-forge signature or phrase that will identify you in place of your name.
        <label class='direction-choice'><input type='radio' name='signature' onchange='onlyDisplayDraw()'/>Draw this special signature</label>
        <label class='direction-choice'><input type='radio' name='signature' onchange='onlyDisplayWrite()'/>Write this special phrase</label>`)
      }

      function activateCheckbox(number) {
        const cb = document.getElementById(`intro-${number}`)
        if (cb) {
          cb.checked = !cb.checked
        }

        // TODO: actually keep track of how many are checked and respond :)
        // if the count >= 3, then show the next step
      }

      function onlyDisplayDraw() {
        showOrHideSelector("#signature-draw", true)
        showOrHideSelector("#signature-write", false)
        showOrHideSelector("#signature", true)
      }
      
      function onlyDisplayWrite() {
        showOrHideSelector("#signature-draw", false)
        showOrHideSelector("#signature-write", true)
        showOrHideSelector("#signature", true)
      }

      function updateDirection(html) {
        const direction = document.getElementById("direction")
        if (direction) {
          direction.classList.remove("hidden")
          direction.innerHTML = html
        }
      }

      function resetDirection() {
        const direction = document.getElementById("direction")
        if (direction) {
          direction.classList.add("hidden")
          direction.innerHTML = ""
        }
      }

      function showOrHideSelector(selector, visibility = true) {
        const element = document.querySelector(selector)
        if (element && visibility) {
          element.classList.remove("hidden")
        } else if (element && !visibility) {
          element.classList.add("hidden")
        }
      }

      function displayNext() {
        showOrHideSelector("#next", true)
        state.activeAreas.push({startX: 37, startY: 9, endX: 39, endY: 11, activation: () => window.location.assign("./websitevibe-scene3.html")})
      }

      function toggleGrid() {
        const html = document.documentElement
        if (html && html.classList.contains("grid")) {
          html.classList.remove("grid")
        } else if (html) {
          html.classList.add("grid")
        }
      }

      function positionInPlace(element) {
        const { top, left } = element.getBoundingClientRect()
        const { scrollX, scrollY } = window
        setTopLeft(element, top + scrollY, left + scrollX)
      }

      function setPositionAbsolute(element) {
        element.style.setProperty("position", "absolute")
      }

      function setTopLeft(element, top, left) {
        element.style.setProperty("top", top + "px")
        element.style.setProperty("left", left + "px")
      }

      // Convert grid coordinates like (1, 2) to pixel values (50px, 100px)
      function gridToPixels(n) {
        return n * GRID_SIZE_PX
      }

      // Convert pixels to nearest grid coordinates like (55px, 5px) to (1, 0)
      function pixelsToGrid(n) {
        const nearestGridPixelValue = n - (n % GRID_SIZE_PX)
        return nearestGridPixelValue / GRID_SIZE_PX
      }

      function positionOnGrid(element, x, y, center = true) {
        // Scale the (x, y) of the grid to pixels on screen
        const xPixels = gridToPixels(x)
        const yPixels = gridToPixels(y)

        // Center the element in the grid cell
        let xOffset = 0
        let yOffset = 0
        if (center) {
          const { height, width } = element.getBoundingClientRect()
          if (height > 0 && width > 0) {
            xOffset = (GRID_SIZE_PX - width) / 2
            yOffset = (GRID_SIZE_PX - height) / 2
          }
        }
        // Position element precisely
        setTopLeft(element, yPixels + yOffset, xPixels + xOffset)
      }

      function positionOnGridBySelector(selector, positions) {
        const elements = document.querySelectorAll(selector)
        elements.forEach((e, i) => {
          const p = positions[i]
          if (!p) {
            console.warn(`no position specified for ${selector} #${i}`)
            return
          }

          positionOnGrid(e, p.x, p.y, p.center)
          setPositionAbsolute(e)
        })
      }

      // Check if an (x, y) are within an area of {startX, startY, endX, endY} coordinates
      function checkInsideCoords(x, y, coords) {
        const endX = coords.endX ?? coords.startX
        const endY = coords.endY ?? coords.startY
        if (x >= coords.startX && x <= endX && y >= coords.startY && y <= endY) {
          return true
        }
        return false
      }

      // Check if an (x, y) is beyond an area of {startX, startY, endX, endY} coordinates
      function checkExceedCoords(x, y, coords) {
        const endX = coords.endX ?? Infinity
        const endY = coords.endY ?? Infinity
        if (x < coords.startX || x > endX || y < coords.startY || y > endY) {
          return true
        }
        return false
      }

      // Returns whether or not the coordinates overlap with an obstacle
      // or a boundary
      function canMoveTo(x, y) {
        // Check boundaries first
        for (let i = 0; i < state.boundaries.length; i++) {
          const exceeds = checkExceedCoords(x, y, state.boundaries[i])
          if (exceeds) {
            return false
          }
        }
        // Check obstacles next
        for (let i = 0; i < state.obstacles.length; i++) {
          const inside = checkInsideCoords(x, y, state.obstacles[i])
          if (inside) {
            return false
          }
        }
        return true
      }

      function activateAreaIfOverlap(x, y) {
        for (let i = 0; i < state.activeAreas.length; i++) {
          const area = state.activeAreas[i]
          const inside = checkInsideCoords(x, y, area)
          const alreadyActive = state.activeArea === area
          if (inside) {
            if (!alreadyActive) {
              state.activeArea = area
              area.activation()
            }
            // We don't need to check other active points
            // since there should only be one at once
            return
          }
        }

        // Since there aren't any active areas
        // reset this state
        state.activeArea = null
      }

      function positionAvatarOnGrid(element, x, y) {
        const canMove = canMoveTo(x, y)
        if (canMove) {
          positionOnGrid(element, x, y)
          activateAreaIfOverlap(x, y)
          // TODO: scroll into view if off viewport
        }
      }

      function moveDirectionOnGrid(element, direction) {
        const { top, left } = element.getBoundingClientRect()
        const { scrollX, scrollY } = window
        // Convert element's position (with scroll) to grid coordinates
        const gridX = pixelsToGrid(left + scrollX)
        const gridY = pixelsToGrid(top + scrollY)
        // console.log(`Nearest grid for (${left}px, ${top}px) is (${gridX}, ${gridY})`)
        // Change grid coordinates based on direction
        let nextGridX = gridX
        let nextGridY = gridY
        switch(direction) {
          case UP:
            nextGridY--
            break
          case DOWN:
            nextGridY++
            break
          case LEFT:
            nextGridX--
            break
          case RIGHT:
            nextGridX++
            break
        }
        // Position element with grid cooridnates
        positionAvatarOnGrid(element, nextGridX, nextGridY)
      }

      function onKeyDown(event) {
        const you = document.getElementById("you")
        switch(event.key) {
          case 'ArrowUp':
            event.preventDefault()
            moveDirectionOnGrid(you, UP)
            break
          case 'ArrowDown':
            event.preventDefault()
            moveDirectionOnGrid(you, DOWN)
            break
          case 'ArrowLeft':
            event.preventDefault()
            moveDirectionOnGrid(you, LEFT)
            break
          case 'ArrowRight':
            event.preventDefault()
            moveDirectionOnGrid(you, RIGHT)
            break
        }
      }

      document.addEventListener("DOMContentLoaded", () => {
         // position elements on grid based on their pre-defined locations
         for (const selector of Object.keys(initialPositions)) {
          const positions = initialPositions[selector]
          positionOnGridBySelector(selector, positions)
        }

        // get the tagged obstacles and record their grid positions
        const obstacles = document.querySelectorAll('[data-obstacle]')
        obstacles.forEach((o) => {
          const { scrollX, scrollY } = window
          const { top, left, width, height } = o.getBoundingClientRect()
          const position = { startX: pixelsToGrid(scrollX + left), startY: pixelsToGrid(scrollY + top) }
          // It's possible this might be a bit buggy hehe
          if (width > GRID_SIZE_PX) {
            position.endX = pixelsToGrid(scrollX + left + width)
          }

          if (height > GRID_SIZE_PX) {
            position.endX = pixelsToGrid(scrollY + top + height)
          }
          state.obstacles.push(position)
        })

        // Move the avatar based on arrow presses
        document.addEventListener("keydown", onKeyDown)
      })
    </script>
  </head>
  <body>
    <nav>
      <a href="/">back</a>
      <button class="toggle" onclick="toggleGrid()">toggle grid</button>
    </nav>
    <main>
      <p id="direction" class="hidden"></p>
      <figure id="you" class="cell center">you</figure>
      <section id="ocean"></section>
      <section id="island"></section>
      <figure class="tree cell center" data-obstacle></figure>
      <figure class="tree cell center" data-obstacle></figure>
      <figure class="tree cell center" data-obstacle></figure>
      <figure class="tree cell center" data-obstacle></figure>
      <figure class="tree cell center" data-obstacle>tree</figure>
      <figure class="tree cell center" data-obstacle></figure>
      <figure class="tree cell center" data-obstacle></figure>
      <figure class="tree cell center" data-obstacle>tree</figure>
      <figure class="intro cell center" data-obstacle>
        <input id="intro-1" type="checkbox" />
        <label for="intro-1">trust</label>
      </figure>
      <figure class="intro cell center" data-obstacle>
        <input id="intro-2" type="checkbox" />
        <label for="intro-2">trust</label>
      </figure>
      <figure class="intro cell center" data-obstacle>
        <input id="intro-3" type="checkbox" />
        <label for="intro-3">trust</label>
      </figure>
      <figure class="intro cell center" data-obstacle>
        <input id="intro-4" type="checkbox" />
        <label for="intro-4">trust</label>
      </figure>
      <figure class="intro cell center" data-obstacle>
        <input id="intro-5" type="checkbox" />
        <label for="intro-5">trust</label>
      </figure>
      <figure class="intro cell center" data-obstacle>
        <input id="intro-6" type="checkbox" />
        <label for="intro-6">trust</label>
      </figure>
      <figure class="pen cell center" data-obstacle>pen</figure>
      <figure id="signature" class="hidden">
        <p id="signature-draw" class="hidden">just imagine you can draw here</p>
        <input id="signature-write" class="hidden" type="text" />
        <button class="direction-button" type="submit" onclick="displayNext()">sign</button>
      </figure>
      <a id="next" class="hidden center cell" href="#doesn't-exist-yet">next</a>
    </main>
  </body>
  <!-- Just for easy editing, can be removed later -->
  <script src="./draggable.js"></script>
</html>